// SPDX-License-Identifier: MIT

//! This file is @generated by the build script, do not edit by hand.
use either::Either;
use rowan::NodeOrToken;
use crate::{
    AstNode, AstToken, SyntaxKind, SyntaxNode, SyntaxToken, tokens::*,
    utils::SyntaxNodeExt,
};
/// Represents the `Block` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockNode {
    syntax: SyntaxNode,
}
impl AstNode for BlockNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BLOCK_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl BlockNode {
    /// Find a child token of variant [SyntaxKind::L_BRACE_TOKEN].
    pub fn l_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::L_BRACE_TOKEN, 0usize)
    }
    /// Find a child node of type [BlockItemsNode].
    pub fn items_node(&self) -> Option<BlockItemsNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::R_BRACE_TOKEN].
    pub fn r_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::R_BRACE_TOKEN, 0usize)
    }
}
/// Represents the `BlockItems` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockItemsNode {
    syntax: SyntaxNode,
}
impl AstNode for BlockItemsNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BLOCK_ITEMS_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl BlockItemsNode {
    /// Find all children nodes of type [ItemNode].
    pub fn items_nodes(&self) -> impl Iterator<Item = ItemNode> {
        self.syntax.children().filter_map(ItemNode::cast)
    }
}
/// Represents the `Item` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ItemNode {
    syntax: SyntaxNode,
}
impl AstNode for ItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ItemNode {
    /// Find a child node of type [VisNode].
    pub fn vis_node(&self) -> Option<VisNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [ItemKindNode].
    pub fn kind_node(&self) -> Option<ItemKindNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::SEMICOLON_TOKEN].
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::SEMICOLON_TOKEN, 0usize)
    }
}
/// Represents the `Name` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameNode {
    syntax: SyntaxNode,
}
impl AstNode for NameNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::NAME_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl NameNode {
    /// Find a child token of variant [SyntaxKind::LIT_IDENT_TOKEN].
    pub fn lit_ident_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::LIT_IDENT_TOKEN, 0usize)
    }
}
/// Represents the `Visibility` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VisNode {
    syntax: SyntaxNode,
}
impl AstNode for VisNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::VIS_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl VisNode {
    /// Find a child token of variant [SyntaxKind::PUB_TOKEN].
    pub fn pub_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::PUB_TOKEN, 0usize)
    }
}
/// Represents the `Mutability` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MutnessNode {
    syntax: SyntaxNode,
}
impl AstNode for MutnessNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::MUTNESS_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl MutnessNode {
    /// Find a child token of variant [SyntaxKind::MUT_TOKEN].
    pub fn mut_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::MUT_TOKEN, 0usize)
    }
}
/// Represents the `ExprSpecifier` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprSpecNode {
    syntax: SyntaxNode,
}
impl AstNode for ExprSpecNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::EXPR_SPEC_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ExprSpecNode {
    /// Find a child token of variant [SyntaxKind::EQ_TOKEN].
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::EQ_TOKEN, 0usize)
    }
    /// Find a child node of type [ExprNode].
    pub fn expr_node(&self) -> Option<ExprNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `Expr` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ExprNode {
    /// See [NameNode].
    Name(NameNode),
    /// See [PrefixExprNode].
    PrefixExpr(PrefixExprNode),
    /// See [BinaryExprNode].
    BinaryExpr(BinaryExprNode),
    /// See [CallExprNode].
    CallExpr(CallExprNode),
    /// See [LitExprNode].
    LitExpr(LitExprNode),
    /// See [ParenExprNode].
    ParenExpr(ParenExprNode),
}
impl AstNode for ExprNode {
    #[allow(clippy::match_like_matches_macro)]
    #[allow(clippy::wildcard_enum_match_arm)]
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SyntaxKind::NAME_NODE => true,
            SyntaxKind::PREFIX_EXPR_NODE => true,
            SyntaxKind::BINARY_EXPR_NODE => true,
            SyntaxKind::CALL_EXPR_NODE => true,
            SyntaxKind::LIT_EXPR_NODE => true,
            SyntaxKind::PAREN_EXPR_NODE => true,
            _ => false,
        }
    }
    #[allow(clippy::wildcard_enum_match_arm)]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            SyntaxKind::NAME_NODE => Some(ExprNode::Name(NameNode::cast(syntax)?)),
            SyntaxKind::PREFIX_EXPR_NODE => {
                Some(ExprNode::PrefixExpr(PrefixExprNode::cast(syntax)?))
            }
            SyntaxKind::BINARY_EXPR_NODE => {
                Some(ExprNode::BinaryExpr(BinaryExprNode::cast(syntax)?))
            }
            SyntaxKind::CALL_EXPR_NODE => {
                Some(ExprNode::CallExpr(CallExprNode::cast(syntax)?))
            }
            SyntaxKind::LIT_EXPR_NODE => {
                Some(ExprNode::LitExpr(LitExprNode::cast(syntax)?))
            }
            SyntaxKind::PAREN_EXPR_NODE => {
                Some(ExprNode::ParenExpr(ParenExprNode::cast(syntax)?))
            }
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ExprNode::Name(it) => it.syntax(),
            ExprNode::PrefixExpr(it) => it.syntax(),
            ExprNode::BinaryExpr(it) => it.syntax(),
            ExprNode::CallExpr(it) => it.syntax(),
            ExprNode::LitExpr(it) => it.syntax(),
            ExprNode::ParenExpr(it) => it.syntax(),
        }
    }
}
/// Represents the `TypeQualifier` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeQualNode {
    syntax: SyntaxNode,
}
impl AstNode for TypeQualNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::TYPE_QUAL_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl TypeQualNode {
    /// Find a child token of variant [SyntaxKind::COLON_TOKEN].
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::COLON_TOKEN, 0usize)
    }
    /// Find a child node of type [TypeNode].
    pub fn type_node(&self) -> Option<TypeNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `Type` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TypeNode {
    /// See [NameTypeNode].
    NameType(NameTypeNode),
    /// See [RefTypeNode].
    RefType(RefTypeNode),
    /// See [BinaryTypeNode].
    BinaryType(BinaryTypeNode),
}
impl AstNode for TypeNode {
    #[allow(clippy::match_like_matches_macro)]
    #[allow(clippy::wildcard_enum_match_arm)]
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SyntaxKind::NAME_TYPE_NODE => true,
            SyntaxKind::REF_TYPE_NODE => true,
            SyntaxKind::BINARY_TYPE_NODE => true,
            _ => false,
        }
    }
    #[allow(clippy::wildcard_enum_match_arm)]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            SyntaxKind::NAME_TYPE_NODE => {
                Some(TypeNode::NameType(NameTypeNode::cast(syntax)?))
            }
            SyntaxKind::REF_TYPE_NODE => {
                Some(TypeNode::RefType(RefTypeNode::cast(syntax)?))
            }
            SyntaxKind::BINARY_TYPE_NODE => {
                Some(TypeNode::BinaryType(BinaryTypeNode::cast(syntax)?))
            }
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TypeNode::NameType(it) => it.syntax(),
            TypeNode::RefType(it) => it.syntax(),
            TypeNode::BinaryType(it) => it.syntax(),
        }
    }
}
/// Represents the `ItemKind` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ItemKindNode {
    /// See [AbstractItemNode].
    AbstractItem(AbstractItemNode),
    /// See [ConstItemNode].
    ConstItem(ConstItemNode),
    /// See [EnumItemNode].
    EnumItem(EnumItemNode),
    /// See [ExprNode].
    Expr(ExprNode),
    /// See [FnItemNode].
    FnItem(FnItemNode),
    /// See [ImportItemNode].
    ImportItem(ImportItemNode),
    /// See [ReturnItemNode].
    ReturnItem(ReturnItemNode),
    /// See [StructItemNode].
    StructItem(StructItemNode),
    /// See [TypeAliasItemNode].
    TypeAliasItem(TypeAliasItemNode),
}
impl AstNode for ItemKindNode {
    #[allow(clippy::match_like_matches_macro)]
    #[allow(clippy::wildcard_enum_match_arm)]
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SyntaxKind::ABSTRACT_ITEM_NODE => true,
            SyntaxKind::CONST_ITEM_NODE => true,
            SyntaxKind::ENUM_ITEM_NODE => true,
            SyntaxKind::EXPR_NODE => true,
            SyntaxKind::FN_ITEM_NODE => true,
            SyntaxKind::IMPORT_ITEM_NODE => true,
            SyntaxKind::RETURN_ITEM_NODE => true,
            SyntaxKind::STRUCT_ITEM_NODE => true,
            SyntaxKind::TYPE_ALIAS_ITEM_NODE => true,
            _ => false,
        }
    }
    #[allow(clippy::wildcard_enum_match_arm)]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            SyntaxKind::ABSTRACT_ITEM_NODE => {
                Some(ItemKindNode::AbstractItem(AbstractItemNode::cast(syntax)?))
            }
            SyntaxKind::CONST_ITEM_NODE => {
                Some(ItemKindNode::ConstItem(ConstItemNode::cast(syntax)?))
            }
            SyntaxKind::ENUM_ITEM_NODE => {
                Some(ItemKindNode::EnumItem(EnumItemNode::cast(syntax)?))
            }
            SyntaxKind::EXPR_NODE => Some(ItemKindNode::Expr(ExprNode::cast(syntax)?)),
            SyntaxKind::FN_ITEM_NODE => {
                Some(ItemKindNode::FnItem(FnItemNode::cast(syntax)?))
            }
            SyntaxKind::IMPORT_ITEM_NODE => {
                Some(ItemKindNode::ImportItem(ImportItemNode::cast(syntax)?))
            }
            SyntaxKind::RETURN_ITEM_NODE => {
                Some(ItemKindNode::ReturnItem(ReturnItemNode::cast(syntax)?))
            }
            SyntaxKind::STRUCT_ITEM_NODE => {
                Some(ItemKindNode::StructItem(StructItemNode::cast(syntax)?))
            }
            SyntaxKind::TYPE_ALIAS_ITEM_NODE => {
                Some(ItemKindNode::TypeAliasItem(TypeAliasItemNode::cast(syntax)?))
            }
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ItemKindNode::AbstractItem(it) => it.syntax(),
            ItemKindNode::ConstItem(it) => it.syntax(),
            ItemKindNode::EnumItem(it) => it.syntax(),
            ItemKindNode::Expr(it) => it.syntax(),
            ItemKindNode::FnItem(it) => it.syntax(),
            ItemKindNode::ImportItem(it) => it.syntax(),
            ItemKindNode::ReturnItem(it) => it.syntax(),
            ItemKindNode::StructItem(it) => it.syntax(),
            ItemKindNode::TypeAliasItem(it) => it.syntax(),
        }
    }
}
/// Represents the `AbstractItem` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AbstractItemNode {
    syntax: SyntaxNode,
}
impl AstNode for AbstractItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ABSTRACT_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AbstractItemNode {
    /// Find a child token of variant [SyntaxKind::ABSTRACT_TOKEN].
    pub fn abstract_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::ABSTRACT_TOKEN, 0usize)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::L_BRACE_TOKEN].
    pub fn l_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::L_BRACE_TOKEN, 0usize)
    }
    /// Find a child node of type [AbstractBodyNode].
    pub fn body_node(&self) -> Option<AbstractBodyNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::R_BRACE_TOKEN].
    pub fn r_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::R_BRACE_TOKEN, 0usize)
    }
}
/// Represents the `ConstItem` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstItemNode {
    syntax: SyntaxNode,
}
impl AstNode for ConstItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CONST_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ConstItemNode {
    /// Find a child token of variant [SyntaxKind::CONST_TOKEN].
    pub fn const_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::CONST_TOKEN, 0usize)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [TypeQualNode].
    pub fn ty_node(&self) -> Option<TypeQualNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [ExprSpecNode].
    pub fn value_node(&self) -> Option<ExprSpecNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `EnumItem` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumItemNode {
    syntax: SyntaxNode,
}
impl AstNode for EnumItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl EnumItemNode {
    /// Find a child token of variant [SyntaxKind::ENUM_TOKEN].
    pub fn enum_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::ENUM_TOKEN, 0usize)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::L_BRACE_TOKEN].
    pub fn l_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::L_BRACE_TOKEN, 0usize)
    }
    /// Find a child node of type [EnumBodyNode].
    pub fn body_node(&self) -> Option<EnumBodyNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::R_BRACE_TOKEN].
    pub fn r_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::R_BRACE_TOKEN, 0usize)
    }
}
/// Represents the `FnItem` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnItemNode {
    syntax: SyntaxNode,
}
impl AstNode for FnItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl FnItemNode {
    /// Find a child token of variant [SyntaxKind::DEF_TOKEN].
    pub fn def_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::DEF_TOKEN, 0usize)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [FnSignatureNode].
    pub fn sig_node(&self) -> Option<FnSignatureNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [BlockNode].
    pub fn body_node(&self) -> Option<BlockNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `ImportItem` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportItemNode {
    syntax: SyntaxNode,
}
impl AstNode for ImportItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ImportItemNode {
    /// Find a child token of variant [SyntaxKind::IMPORT_TOKEN].
    pub fn import_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::IMPORT_TOKEN, 0usize)
    }
    /// Find a child node of type [ImportTreeNode].
    pub fn tree_node(&self) -> Option<ImportTreeNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `ReturnItem` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnItemNode {
    syntax: SyntaxNode,
}
impl AstNode for ReturnItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::RETURN_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ReturnItemNode {
    /// Find a child token of variant [SyntaxKind::RETURN_TOKEN].
    pub fn return_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::RETURN_TOKEN, 0usize)
    }
    /// Find a child node of type [ExprNode].
    pub fn expr_node(&self) -> Option<ExprNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `StructItem` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructItemNode {
    syntax: SyntaxNode,
}
impl AstNode for StructItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl StructItemNode {
    /// Find a child token of variant [SyntaxKind::STRUCT_TOKEN].
    pub fn struct_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::STRUCT_TOKEN, 0usize)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::L_BRACE_TOKEN].
    pub fn l_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::L_BRACE_TOKEN, 0usize)
    }
    /// Find a child node of type [StructBodyNode].
    pub fn body_node(&self) -> Option<StructBodyNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::R_BRACE_TOKEN].
    pub fn r_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::R_BRACE_TOKEN, 0usize)
    }
}
/// Represents the `TypeAliasItem` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAliasItemNode {
    syntax: SyntaxNode,
}
impl AstNode for TypeAliasItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::TYPE_ALIAS_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl TypeAliasItemNode {
    /// Find a child token of variant [SyntaxKind::TYPE_TOKEN].
    pub fn type_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::TYPE_TOKEN, 0usize)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::EQ_TOKEN].
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::EQ_TOKEN, 0usize)
    }
    /// Find a child node of type [TypeNode].
    pub fn type_node(&self) -> Option<TypeNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `AbstractBody` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AbstractBodyNode {
    syntax: SyntaxNode,
}
impl AstNode for AbstractBodyNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ABSTRACT_BODY_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AbstractBodyNode {
    /// Find all children nodes of type [AbstractFnItemNode].
    pub fn abstract_fn_items_nodes(&self) -> impl Iterator<Item = AbstractFnItemNode> {
        self.syntax.children().filter_map(AbstractFnItemNode::cast)
    }
}
/// Represents the `AbstractFnItem` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AbstractFnItemNode {
    syntax: SyntaxNode,
}
impl AstNode for AbstractFnItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ABSTRACT_FN_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AbstractFnItemNode {
    /// Find a child token of variant [SyntaxKind::DEF_TOKEN].
    pub fn def_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::DEF_TOKEN, 0usize)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [FnSignatureNode].
    pub fn sig_node(&self) -> Option<FnSignatureNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::SEMICOLON_TOKEN].
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::SEMICOLON_TOKEN, 0usize)
    }
}
/// Represents the `FnSignature` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnSignatureNode {
    syntax: SyntaxNode,
}
impl AstNode for FnSignatureNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_SIGNATURE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl FnSignatureNode {
    /// Find a child token of variant [SyntaxKind::L_PAREN_TOKEN].
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::L_PAREN_TOKEN, 0usize)
    }
    /// Find a child node of type [FnInputsNode].
    pub fn inputs_node(&self) -> Option<FnInputsNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::R_PAREN_TOKEN].
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::R_PAREN_TOKEN, 0usize)
    }
    /// Find a child node of type [TypeQualNode].
    pub fn return_ty_node(&self) -> Option<TypeQualNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `EnumBody` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumBodyNode {
    syntax: SyntaxNode,
}
impl AstNode for EnumBodyNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_BODY_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl EnumBodyNode {
    /// Find all children nodes of type [EnumBodyItemNode].
    pub fn items_nodes(&self) -> impl Iterator<Item = EnumBodyItemNode> {
        self.syntax.children().filter_map(EnumBodyItemNode::cast)
    }
}
/// Represents the `EnumBodyItem` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum EnumBodyItemNode {
    /// See [EnumVariantNode].
    EnumVariant(EnumVariantNode),
    /// See [EnumFnNode].
    EnumFn(EnumFnNode),
}
impl AstNode for EnumBodyItemNode {
    #[allow(clippy::match_like_matches_macro)]
    #[allow(clippy::wildcard_enum_match_arm)]
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SyntaxKind::ENUM_VARIANT_NODE => true,
            SyntaxKind::ENUM_FN_NODE => true,
            _ => false,
        }
    }
    #[allow(clippy::wildcard_enum_match_arm)]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            SyntaxKind::ENUM_VARIANT_NODE => {
                Some(EnumBodyItemNode::EnumVariant(EnumVariantNode::cast(syntax)?))
            }
            SyntaxKind::ENUM_FN_NODE => {
                Some(EnumBodyItemNode::EnumFn(EnumFnNode::cast(syntax)?))
            }
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            EnumBodyItemNode::EnumVariant(it) => it.syntax(),
            EnumBodyItemNode::EnumFn(it) => it.syntax(),
        }
    }
}
/// Represents the `EnumVariant` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariantNode {
    syntax: SyntaxNode,
}
impl AstNode for EnumVariantNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_VARIANT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl EnumVariantNode {
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [EnumVariantDataTypeNode].
    pub fn data_ty_node(&self) -> Option<EnumVariantDataTypeNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::SEMICOLON_TOKEN].
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::SEMICOLON_TOKEN, 0usize)
    }
}
/// Represents the `EnumFn` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumFnNode {
    syntax: SyntaxNode,
}
impl AstNode for EnumFnNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_FN_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl EnumFnNode {
    /// Find a child node of type [VisNode].
    pub fn vis_node(&self) -> Option<VisNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [FnItemNode].
    pub fn fn_item_node(&self) -> Option<FnItemNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `EnumVariantDataType` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariantDataTypeNode {
    syntax: SyntaxNode,
}
impl AstNode for EnumVariantDataTypeNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_VARIANT_DATA_TYPE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl EnumVariantDataTypeNode {
    /// Find a child token of variant [SyntaxKind::L_PAREN_TOKEN].
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::L_PAREN_TOKEN, 0usize)
    }
    /// Find a child node of type [TypeNode].
    pub fn type_node(&self) -> Option<TypeNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::R_PAREN_TOKEN].
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::R_PAREN_TOKEN, 0usize)
    }
}
/// Represents the `FnInputs` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnInputsNode {
    syntax: SyntaxNode,
}
impl AstNode for FnInputsNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_INPUTS_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl FnInputsNode {
    /// Returns an iterator over the children nodes of this node.
    pub fn children(&self) -> impl Iterator<Item = FnInputNode> {
        self.children_with_delimiters()
            .filter_map(|either| match either {
                Either::Left(node) => Some(node),
                Either::Right(_) => None,
            })
    }
    /// Returns an iterator over the children nodes and token of this node.
    pub fn children_with_delimiters(
        &self,
    ) -> impl Iterator<Item = Either<FnInputNode, CommaToken>> {
        self.syntax
            .children_with_tokens()
            .filter_map(|node_or_token| match node_or_token {
                NodeOrToken::Node(node) => FnInputNode::cast(node).map(Either::Left),
                NodeOrToken::Token(token) => CommaToken::cast(token).map(Either::Right),
            })
    }
}
/// Represents the `FnInput` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnInputNode {
    syntax: SyntaxNode,
}
impl AstNode for FnInputNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_INPUT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl FnInputNode {
    /// Find a child node of type [MutnessNode].
    pub fn mutness_node(&self) -> Option<MutnessNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [TypeQualNode].
    pub fn ty_node(&self) -> Option<TypeQualNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [ExprSpecNode].
    pub fn default_node(&self) -> Option<ExprSpecNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `ImportTree` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ImportTreeNode {
    /// See [ImportLeafNode].
    ImportLeaf(ImportLeafNode),
    /// See [ImportBranchNode].
    ImportBranch(ImportBranchNode),
}
impl AstNode for ImportTreeNode {
    #[allow(clippy::match_like_matches_macro)]
    #[allow(clippy::wildcard_enum_match_arm)]
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SyntaxKind::IMPORT_LEAF_NODE => true,
            SyntaxKind::IMPORT_BRANCH_NODE => true,
            _ => false,
        }
    }
    #[allow(clippy::wildcard_enum_match_arm)]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            SyntaxKind::IMPORT_LEAF_NODE => {
                Some(ImportTreeNode::ImportLeaf(ImportLeafNode::cast(syntax)?))
            }
            SyntaxKind::IMPORT_BRANCH_NODE => {
                Some(ImportTreeNode::ImportBranch(ImportBranchNode::cast(syntax)?))
            }
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ImportTreeNode::ImportLeaf(it) => it.syntax(),
            ImportTreeNode::ImportBranch(it) => it.syntax(),
        }
    }
}
/// Represents the `ImportLeaf` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportLeafNode {
    syntax: SyntaxNode,
}
impl AstNode for ImportLeafNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_LEAF_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ImportLeafNode {
    /// Find a child node of type [NameNode].
    pub fn segment_node(&self) -> Option<NameNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [ImportSegmentNode].
    pub fn rest_node(&self) -> Option<ImportSegmentNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `ImportBranch` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportBranchNode {
    syntax: SyntaxNode,
}
impl AstNode for ImportBranchNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_BRANCH_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ImportBranchNode {
    /// Find a child token of variant [SyntaxKind::L_BRACE_TOKEN].
    pub fn l_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::L_BRACE_TOKEN, 0usize)
    }
    /// Find a child node of type [ImportBranchSubtreesNode].
    pub fn subtrees_node(&self) -> Option<ImportBranchSubtreesNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::R_BRACE_TOKEN].
    pub fn r_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::R_BRACE_TOKEN, 0usize)
    }
}
/// Represents the `ImportSegment` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportSegmentNode {
    syntax: SyntaxNode,
}
impl AstNode for ImportSegmentNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_SEGMENT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ImportSegmentNode {
    /// Find a child token of variant [SyntaxKind::DOT_TOKEN].
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::DOT_TOKEN, 0usize)
    }
    /// Find a child node of type [ImportTreeNode].
    pub fn subtree_node(&self) -> Option<ImportTreeNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `ImportBranchSubtrees` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportBranchSubtreesNode {
    syntax: SyntaxNode,
}
impl AstNode for ImportBranchSubtreesNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_BRANCH_SUBTREES_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ImportBranchSubtreesNode {
    /// Returns an iterator over the children nodes of this node.
    pub fn children(&self) -> impl Iterator<Item = ImportTreeNode> {
        self.children_with_delimiters()
            .filter_map(|either| match either {
                Either::Left(node) => Some(node),
                Either::Right(_) => None,
            })
    }
    /// Returns an iterator over the children nodes and token of this node.
    pub fn children_with_delimiters(
        &self,
    ) -> impl Iterator<Item = Either<ImportTreeNode, CommaToken>> {
        self.syntax
            .children_with_tokens()
            .filter_map(|node_or_token| match node_or_token {
                NodeOrToken::Node(node) => ImportTreeNode::cast(node).map(Either::Left),
                NodeOrToken::Token(token) => CommaToken::cast(token).map(Either::Right),
            })
    }
}
/// Represents the `StructBody` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructBodyNode {
    syntax: SyntaxNode,
}
impl AstNode for StructBodyNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_BODY_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl StructBodyNode {
    /// Find all children nodes of type [StructBodyItemNode].
    pub fn items_nodes(&self) -> impl Iterator<Item = StructBodyItemNode> {
        self.syntax.children().filter_map(StructBodyItemNode::cast)
    }
}
/// Represents the `StructBodyItem` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum StructBodyItemNode {
    /// See [StructFieldNode].
    StructField(StructFieldNode),
    /// See [StructFnNode].
    StructFn(StructFnNode),
}
impl AstNode for StructBodyItemNode {
    #[allow(clippy::match_like_matches_macro)]
    #[allow(clippy::wildcard_enum_match_arm)]
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SyntaxKind::STRUCT_FIELD_NODE => true,
            SyntaxKind::STRUCT_FN_NODE => true,
            _ => false,
        }
    }
    #[allow(clippy::wildcard_enum_match_arm)]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            SyntaxKind::STRUCT_FIELD_NODE => {
                Some(StructBodyItemNode::StructField(StructFieldNode::cast(syntax)?))
            }
            SyntaxKind::STRUCT_FN_NODE => {
                Some(StructBodyItemNode::StructFn(StructFnNode::cast(syntax)?))
            }
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            StructBodyItemNode::StructField(it) => it.syntax(),
            StructBodyItemNode::StructFn(it) => it.syntax(),
        }
    }
}
/// Represents the `StructField` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructFieldNode {
    syntax: SyntaxNode,
}
impl AstNode for StructFieldNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_FIELD_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl StructFieldNode {
    /// Find a child node of type [VisNode].
    pub fn vis_node(&self) -> Option<VisNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [TypeQualNode].
    pub fn ty_node(&self) -> Option<TypeQualNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::SEMICOLON_TOKEN].
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::SEMICOLON_TOKEN, 0usize)
    }
}
/// Represents the `StructFn` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructFnNode {
    syntax: SyntaxNode,
}
impl AstNode for StructFnNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_FN_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl StructFnNode {
    /// Find a child node of type [VisNode].
    pub fn vis_node(&self) -> Option<VisNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [FnItemNode].
    pub fn fn_item_node(&self) -> Option<FnItemNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `NameType` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameTypeNode {
    syntax: SyntaxNode,
}
impl AstNode for NameTypeNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::NAME_TYPE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl NameTypeNode {
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [NameTypeGenericsNode].
    pub fn generics_node(&self) -> Option<NameTypeGenericsNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `RefType` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefTypeNode {
    syntax: SyntaxNode,
}
impl AstNode for RefTypeNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::REF_TYPE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl RefTypeNode {
    /// Find a child token of variant [SyntaxKind::AMP_TOKEN].
    pub fn amp_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::AMP_TOKEN, 0usize)
    }
    /// Find a child node of type [MutnessNode].
    pub fn mutness_node(&self) -> Option<MutnessNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [TypeNode].
    pub fn type_node(&self) -> Option<TypeNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `BinaryType` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryTypeNode {
    syntax: SyntaxNode,
}
impl AstNode for BinaryTypeNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BINARY_TYPE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl BinaryTypeNode {
    /// Find a child node of type [TypeNode].
    pub fn lhs_node(&self) -> Option<TypeNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [BinaryTypeOpNode].
    pub fn op_node(&self) -> Option<BinaryTypeOpNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [TypeNode].
    pub fn rhs_node(&self) -> Option<TypeNode> {
        self.syntax.child(1usize)
    }
}
/// Represents the `NameTypeGenerics` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameTypeGenericsNode {
    syntax: SyntaxNode,
}
impl AstNode for NameTypeGenericsNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::NAME_TYPE_GENERICS_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl NameTypeGenericsNode {
    /// Find a child token of variant [SyntaxKind::L_BRACKET_TOKEN].
    pub fn l_bracket_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::L_BRACKET_TOKEN, 0usize)
    }
    /// Find a child node of type [NameTypeGenericsInnerNode].
    pub fn generics_node(&self) -> Option<NameTypeGenericsInnerNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::R_BRACKET_TOKEN].
    pub fn r_bracket_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::R_BRACKET_TOKEN, 0usize)
    }
}
/// Represents the `NameTypeGenericsInner` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameTypeGenericsInnerNode {
    syntax: SyntaxNode,
}
impl AstNode for NameTypeGenericsInnerNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::NAME_TYPE_GENERICS_INNER_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl NameTypeGenericsInnerNode {
    /// Returns an iterator over the children nodes of this node.
    pub fn children(&self) -> impl Iterator<Item = TypeNode> {
        self.children_with_delimiters()
            .filter_map(|either| match either {
                Either::Left(node) => Some(node),
                Either::Right(_) => None,
            })
    }
    /// Returns an iterator over the children nodes and token of this node.
    pub fn children_with_delimiters(
        &self,
    ) -> impl Iterator<Item = Either<TypeNode, CommaToken>> {
        self.syntax
            .children_with_tokens()
            .filter_map(|node_or_token| match node_or_token {
                NodeOrToken::Node(node) => TypeNode::cast(node).map(Either::Left),
                NodeOrToken::Token(token) => CommaToken::cast(token).map(Either::Right),
            })
    }
}
/// Represents the `BinaryTypeOp` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryTypeOpNode {
    syntax: SyntaxNode,
}
impl AstNode for BinaryTypeOpNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BINARY_TYPE_OP_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl BinaryTypeOpNode {
    /// Find a child token of variant [SyntaxKind::PLUS_TOKEN].
    pub fn plus_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::PLUS_TOKEN, 0usize)
    }
}
/// Represents the `PrefixExpr` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExprNode {
    syntax: SyntaxNode,
}
impl AstNode for PrefixExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PREFIX_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl PrefixExprNode {
    /// Find a child node of type [PrefixExprOpNode].
    pub fn op_node(&self) -> Option<PrefixExprOpNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [ExprNode].
    pub fn expr_node(&self) -> Option<ExprNode> {
        self.syntax.child(0usize)
    }
}
/// Represents the `BinaryExpr` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryExprNode {
    syntax: SyntaxNode,
}
impl AstNode for BinaryExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BINARY_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl BinaryExprNode {
    /// Find a child node of type [ExprNode].
    pub fn lhs_node(&self) -> Option<ExprNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [BinaryExprOpNode].
    pub fn op_node(&self) -> Option<BinaryExprOpNode> {
        self.syntax.child(0usize)
    }
    /// Find a child node of type [ExprNode].
    pub fn rhs_node(&self) -> Option<ExprNode> {
        self.syntax.child(1usize)
    }
}
/// Represents the `CallExpr` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExprNode {
    syntax: SyntaxNode,
}
impl AstNode for CallExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CALL_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl CallExprNode {
    /// Find a child node of type [ExprNode].
    pub fn callee_node(&self) -> Option<ExprNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::L_PAREN_TOKEN].
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::L_PAREN_TOKEN, 0usize)
    }
    /// Find a child node of type [CallExprArgsNode].
    pub fn args_node(&self) -> Option<CallExprArgsNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::R_PAREN_TOKEN].
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::R_PAREN_TOKEN, 0usize)
    }
}
/// Represents the `LitExpr` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LitExprNode {
    syntax: SyntaxNode,
}
impl AstNode for LitExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LIT_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl LitExprNode {
    /// Returns the inner token associated with this node.
    pub fn token(&self) -> Option<LitExprToken> {
        self.syntax
            .children_with_tokens()
            .find_map(|node_or_token| match node_or_token {
                NodeOrToken::Node(_) => None,
                NodeOrToken::Token(token) => LitExprToken::cast(token),
            })
    }
}
/// Represents the `ParenExpr` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExprNode {
    syntax: SyntaxNode,
}
impl AstNode for ParenExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PAREN_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl ParenExprNode {
    /// Find a child token of variant [SyntaxKind::L_PAREN_TOKEN].
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::L_PAREN_TOKEN, 0usize)
    }
    /// Find a child node of type [ExprNode].
    pub fn expr_node(&self) -> Option<ExprNode> {
        self.syntax.child(0usize)
    }
    /// Find a child token of variant [SyntaxKind::R_PAREN_TOKEN].
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.child_token(SyntaxKind::R_PAREN_TOKEN, 0usize)
    }
}
/// Represents the `PrefixExprOp` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExprOpNode {
    syntax: SyntaxNode,
}
impl AstNode for PrefixExprOpNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PREFIX_EXPR_OP_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl PrefixExprOpNode {
    /// Returns the inner token associated with this node.
    pub fn token(&self) -> Option<PrefixExprOpToken> {
        self.syntax
            .children_with_tokens()
            .find_map(|node_or_token| match node_or_token {
                NodeOrToken::Node(_) => None,
                NodeOrToken::Token(token) => PrefixExprOpToken::cast(token),
            })
    }
}
/// Represents the `BinaryExprOp` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryExprOpNode {
    syntax: SyntaxNode,
}
impl AstNode for BinaryExprOpNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BINARY_EXPR_OP_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl BinaryExprOpNode {
    /// Returns the inner token associated with this node.
    pub fn token(&self) -> Option<BinaryExprOpToken> {
        self.syntax
            .children_with_tokens()
            .find_map(|node_or_token| match node_or_token {
                NodeOrToken::Node(_) => None,
                NodeOrToken::Token(token) => BinaryExprOpToken::cast(token),
            })
    }
}
/// Represents the `CallExprArgs` node.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExprArgsNode {
    syntax: SyntaxNode,
}
impl AstNode for CallExprArgsNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CALL_EXPR_ARGS_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl CallExprArgsNode {
    /// Returns an iterator over the children nodes of this node.
    pub fn children(&self) -> impl Iterator<Item = ExprNode> {
        self.children_with_delimiters()
            .filter_map(|either| match either {
                Either::Left(node) => Some(node),
                Either::Right(_) => None,
            })
    }
    /// Returns an iterator over the children nodes and token of this node.
    pub fn children_with_delimiters(
        &self,
    ) -> impl Iterator<Item = Either<ExprNode, CommaToken>> {
        self.syntax
            .children_with_tokens()
            .filter_map(|node_or_token| match node_or_token {
                NodeOrToken::Node(node) => ExprNode::cast(node).map(Either::Left),
                NodeOrToken::Token(token) => CommaToken::cast(token).map(Either::Right),
            })
    }
}
