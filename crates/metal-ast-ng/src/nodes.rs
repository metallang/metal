//! This file is @generated by the build script, do not edit by hand.
use crate::{AstNode, SyntaxKind, SyntaxNode, SyntaxNodeExt, SyntaxToken};
/// Represents the `Name` node.
pub struct NameNode {
    syntax: SyntaxNode,
}
impl NameNode {
    /// Find a child token of variant [SyntaxKind::LIT_IDENT_TOKEN].
    pub fn lit_ident_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::LIT_IDENT_TOKEN)
    }
}
impl AstNode for NameNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::NAME_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Visibility` node.
pub struct VisNode {
    syntax: SyntaxNode,
}
impl VisNode {}
impl AstNode for VisNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::VIS_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Mutability` node.
pub struct MutnessNode {
    syntax: SyntaxNode,
}
impl MutnessNode {}
impl AstNode for MutnessNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::MUTNESS_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ExprSpecifier` node.
pub struct ExprSpecNode {
    syntax: SyntaxNode,
}
impl ExprSpecNode {
    /// Find a child token of variant [SyntaxKind::EQ_TOKEN].
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::EQ_TOKEN)
    }
    /// Find a child node of type [ExprNode].
    pub fn expr_node(&self) -> Option<ExprNode> {
        self.syntax.child()
    }
}
impl AstNode for ExprSpecNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::EXPR_SPEC_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Expr` node.
pub struct ExprNode {
    syntax: SyntaxNode,
}
impl ExprNode {}
impl AstNode for ExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `TypeQualifier` node.
pub struct TypeQualNode {
    syntax: SyntaxNode,
}
impl TypeQualNode {
    /// Find a child token of variant [SyntaxKind::COLON_TOKEN].
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::COLON_TOKEN)
    }
    /// Find a child node of type [TypeNode].
    pub fn type_node(&self) -> Option<TypeNode> {
        self.syntax.child()
    }
}
impl AstNode for TypeQualNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::TYPE_QUAL_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Type` node.
pub struct TypeNode {
    syntax: SyntaxNode,
}
impl TypeNode {
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child()
    }
}
impl AstNode for TypeNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::TYPE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Block` node.
pub struct BlockNode {
    syntax: SyntaxNode,
}
impl BlockNode {
    /// Find a child token of variant [SyntaxKind::L_BRACE_TOKEN].
    pub fn l_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::L_BRACE_TOKEN)
    }
    /// Find a child node of type [ItemNode].
    pub fn item_node(&self) -> Option<ItemNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::R_BRACE_TOKEN].
    pub fn r_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::R_BRACE_TOKEN)
    }
}
impl AstNode for BlockNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BLOCK_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Item` node.
pub struct ItemNode {
    syntax: SyntaxNode,
}
impl ItemNode {}
impl AstNode for ItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ConstItem` node.
pub struct ConstItemNode {
    syntax: SyntaxNode,
}
impl ConstItemNode {
    /// Find a child node of type [VisNode].
    pub fn vis_node(&self) -> Option<VisNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::CONST_TOKEN].
    pub fn const_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::CONST_TOKEN)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child()
    }
    /// Find a child node of type [ExprSpecNode].
    pub fn value_node(&self) -> Option<ExprSpecNode> {
        self.syntax.child()
    }
}
impl AstNode for ConstItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CONST_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumItem` node.
pub struct EnumItemNode {
    syntax: SyntaxNode,
}
impl EnumItemNode {
    /// Find a child node of type [VisNode].
    pub fn vis_node(&self) -> Option<VisNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::ENUM_TOKEN].
    pub fn enum_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::ENUM_TOKEN)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::L_BRACE_TOKEN].
    pub fn l_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::L_BRACE_TOKEN)
    }
    /// Find a child token of variant [SyntaxKind::R_BRACE_TOKEN].
    pub fn r_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::R_BRACE_TOKEN)
    }
}
impl AstNode for EnumItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `FnItem` node.
pub struct FnItemNode {
    syntax: SyntaxNode,
}
impl FnItemNode {
    /// Find a child node of type [VisNode].
    pub fn vis_node(&self) -> Option<VisNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::DEF_TOKEN].
    pub fn def_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::DEF_TOKEN)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child()
    }
    /// Find a child node of type [FnSignatureNode].
    pub fn sig_node(&self) -> Option<FnSignatureNode> {
        self.syntax.child()
    }
    /// Find a child node of type [BlockNode].
    pub fn body_node(&self) -> Option<BlockNode> {
        self.syntax.child()
    }
}
impl AstNode for FnItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportItem` node.
pub struct ImportItemNode {
    syntax: SyntaxNode,
}
impl ImportItemNode {
    /// Find a child node of type [VisNode].
    pub fn vis_node(&self) -> Option<VisNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::IMPORT_TOKEN].
    pub fn import_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::IMPORT_TOKEN)
    }
    /// Find a child node of type [ImportTreeNode].
    pub fn tree_node(&self) -> Option<ImportTreeNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::SEMICOLON_TOKEN].
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::SEMICOLON_TOKEN)
    }
}
impl AstNode for ImportItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StructItem` node.
pub struct StructItemNode {
    syntax: SyntaxNode,
}
impl StructItemNode {
    /// Find a child node of type [VisNode].
    pub fn vis_node(&self) -> Option<VisNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::STRUCT_TOKEN].
    pub fn struct_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::STRUCT_TOKEN)
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::L_BRACE_TOKEN].
    pub fn l_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::L_BRACE_TOKEN)
    }
    /// Find a child node of type [StructBodyNode].
    pub fn body_node(&self) -> Option<StructBodyNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::R_BRACE_TOKEN].
    pub fn r_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::R_BRACE_TOKEN)
    }
}
impl AstNode for StructItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumBody` node.
pub struct EnumBodyNode {
    syntax: SyntaxNode,
}
impl EnumBodyNode {
    /// Find a child node of type [EnumBodyItemNode].
    pub fn enum_body_item_node(&self) -> Option<EnumBodyItemNode> {
        self.syntax.child()
    }
}
impl AstNode for EnumBodyNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_BODY_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumBodyItem` node.
pub struct EnumBodyItemNode {
    syntax: SyntaxNode,
}
impl EnumBodyItemNode {}
impl AstNode for EnumBodyItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_BODY_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumVariant` node.
pub struct EnumVariantNode {
    syntax: SyntaxNode,
}
impl EnumVariantNode {
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child()
    }
}
impl AstNode for EnumVariantNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_VARIANT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumVariantType` node.
pub struct EnumVariantTypeNode {
    syntax: SyntaxNode,
}
impl EnumVariantTypeNode {
    /// Find a child token of variant [SyntaxKind::L_PAREN_TOKEN].
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::L_PAREN_TOKEN)
    }
    /// Find a child node of type [TypeNode].
    pub fn type_node(&self) -> Option<TypeNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::R_PAREN_TOKEN].
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::R_PAREN_TOKEN)
    }
}
impl AstNode for EnumVariantTypeNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_VARIANT_TYPE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `FnSignature` node.
pub struct FnSignatureNode {
    syntax: SyntaxNode,
}
impl FnSignatureNode {
    /// Find a child token of variant [SyntaxKind::L_PAREN_TOKEN].
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::L_PAREN_TOKEN)
    }
    /// Find a child token of variant [SyntaxKind::R_PAREN_TOKEN].
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::R_PAREN_TOKEN)
    }
}
impl AstNode for FnSignatureNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_SIGNATURE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `FnInput` node.
pub struct FnInputNode {
    syntax: SyntaxNode,
}
impl FnInputNode {
    /// Find a child node of type [MutnessNode].
    pub fn mutness_node(&self) -> Option<MutnessNode> {
        self.syntax.child()
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child()
    }
}
impl AstNode for FnInputNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_INPUT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportTree` node.
pub struct ImportTreeNode {
    syntax: SyntaxNode,
}
impl ImportTreeNode {}
impl AstNode for ImportTreeNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_TREE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportLeaf` node.
pub struct ImportLeafNode {
    syntax: SyntaxNode,
}
impl ImportLeafNode {
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child()
    }
}
impl AstNode for ImportLeafNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_LEAF_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportSegment` node.
pub struct ImportSegmentNode {
    syntax: SyntaxNode,
}
impl ImportSegmentNode {
    /// Find a child node of type [NameNode].
    pub fn segment_node(&self) -> Option<NameNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::DOT_TOKEN].
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::DOT_TOKEN)
    }
    /// Find a child node of type [ImportTreeNode].
    pub fn rest_node(&self) -> Option<ImportTreeNode> {
        self.syntax.child()
    }
}
impl AstNode for ImportSegmentNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_SEGMENT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportBranch` node.
pub struct ImportBranchNode {
    syntax: SyntaxNode,
}
impl ImportBranchNode {
    /// Find a child token of variant [SyntaxKind::L_BRACE_TOKEN].
    pub fn l_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::L_BRACE_TOKEN)
    }
    /// Find a child token of variant [SyntaxKind::R_BRACE_TOKEN].
    pub fn r_brace_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::R_BRACE_TOKEN)
    }
}
impl AstNode for ImportBranchNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_BRANCH_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StructBody` node.
pub struct StructBodyNode {
    syntax: SyntaxNode,
}
impl StructBodyNode {
    /// Find a child node of type [StructBodyItemNode].
    pub fn struct_body_item_node(&self) -> Option<StructBodyItemNode> {
        self.syntax.child()
    }
}
impl AstNode for StructBodyNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_BODY_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StructBodyItem` node.
pub struct StructBodyItemNode {
    syntax: SyntaxNode,
}
impl StructBodyItemNode {}
impl AstNode for StructBodyItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_BODY_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StructField` node.
pub struct StructFieldNode {
    syntax: SyntaxNode,
}
impl StructFieldNode {
    /// Find a child node of type [VisNode].
    pub fn vis_node(&self) -> Option<VisNode> {
        self.syntax.child()
    }
    /// Find a child node of type [NameNode].
    pub fn name_node(&self) -> Option<NameNode> {
        self.syntax.child()
    }
    /// Find a child node of type [TypeQualNode].
    pub fn ty_node(&self) -> Option<TypeQualNode> {
        self.syntax.child()
    }
}
impl AstNode for StructFieldNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_FIELD_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `PrefixExpr` node.
pub struct PrefixExprNode {
    syntax: SyntaxNode,
}
impl PrefixExprNode {
    /// Find a child node of type [PrefixOpNode].
    pub fn op_node(&self) -> Option<PrefixOpNode> {
        self.syntax.child()
    }
    /// Find a child node of type [ExprNode].
    pub fn expr_node(&self) -> Option<ExprNode> {
        self.syntax.child()
    }
}
impl AstNode for PrefixExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PREFIX_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `BinaryExpr` node.
pub struct BinaryExprNode {
    syntax: SyntaxNode,
}
impl BinaryExprNode {
    /// Find a child node of type [ExprNode].
    pub fn lhs_node(&self) -> Option<ExprNode> {
        self.syntax.child()
    }
    /// Find a child node of type [BinaryOpNode].
    pub fn op_node(&self) -> Option<BinaryOpNode> {
        self.syntax.child()
    }
    /// Find a child node of type [ExprNode].
    pub fn rhs_node(&self) -> Option<ExprNode> {
        self.syntax.child()
    }
}
impl AstNode for BinaryExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BINARY_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `CallExpr` node.
pub struct CallExprNode {
    syntax: SyntaxNode,
}
impl CallExprNode {
    /// Find a child node of type [ExprNode].
    pub fn expr_node(&self) -> Option<ExprNode> {
        self.syntax.child()
    }
    /// Find a child token of variant [SyntaxKind::L_PAREN_TOKEN].
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::L_PAREN_TOKEN)
    }
    /// Find a child token of variant [SyntaxKind::R_PAREN_TOKEN].
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::R_PAREN_TOKEN)
    }
}
impl AstNode for CallExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CALL_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `LitExpr` node.
pub struct LitExprNode {
    syntax: SyntaxNode,
}
impl LitExprNode {}
impl AstNode for LitExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LIT_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `PrefixOp` node.
pub struct PrefixOpNode {
    syntax: SyntaxNode,
}
impl PrefixOpNode {}
impl AstNode for PrefixOpNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PREFIX_OP_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `BinaryOp` node.
pub struct BinaryOpNode {
    syntax: SyntaxNode,
}
impl BinaryOpNode {}
impl AstNode for BinaryOpNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BINARY_OP_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `NumLit` node.
pub struct NumLitNode {
    syntax: SyntaxNode,
}
impl NumLitNode {
    /// Find a child token of variant [SyntaxKind::LIT_NUM_TOKEN].
    pub fn lit_num_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::LIT_NUM_TOKEN)
    }
}
impl AstNode for NumLitNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::NUM_LIT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StrLit` node.
pub struct StrLitNode {
    syntax: SyntaxNode,
}
impl StrLitNode {
    /// Find a child token of variant [SyntaxKind::LIT_STR_TOKEN].
    pub fn lit_str_token(&self) -> Option<SyntaxToken> {
        self.syntax.find_child_token(SyntaxKind::LIT_STR_TOKEN)
    }
}
impl AstNode for StrLitNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STR_LIT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
