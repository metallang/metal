//! This file is @generated by the build script, do not edit by hand.
use crate::{AstNode, SyntaxKind, SyntaxNode};
/// Represents the `Name` node.
pub struct NameNode {
    syntax: SyntaxNode,
}
impl AstNode for NameNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::NAME_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Visibility` node.
pub struct VisNode {
    syntax: SyntaxNode,
}
impl AstNode for VisNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::VIS_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Mutability` node.
pub struct MutnessNode {
    syntax: SyntaxNode,
}
impl AstNode for MutnessNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::MUTNESS_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ExprSpecifier` node.
pub struct ExprSpecNode {
    syntax: SyntaxNode,
}
impl AstNode for ExprSpecNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::EXPR_SPEC_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Expr` node.
pub struct ExprNode {
    syntax: SyntaxNode,
}
impl AstNode for ExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `TypeQualifier` node.
pub struct TypeQualNode {
    syntax: SyntaxNode,
}
impl AstNode for TypeQualNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::TYPE_QUAL_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Type` node.
pub struct TypeNode {
    syntax: SyntaxNode,
}
impl AstNode for TypeNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::TYPE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Block` node.
pub struct BlockNode {
    syntax: SyntaxNode,
}
impl AstNode for BlockNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BLOCK_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Item` node.
pub struct ItemNode {
    syntax: SyntaxNode,
}
impl AstNode for ItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ConstItem` node.
pub struct ConstItemNode {
    syntax: SyntaxNode,
}
impl AstNode for ConstItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CONST_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumItem` node.
pub struct EnumItemNode {
    syntax: SyntaxNode,
}
impl AstNode for EnumItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `FnItem` node.
pub struct FnItemNode {
    syntax: SyntaxNode,
}
impl AstNode for FnItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportItem` node.
pub struct ImportItemNode {
    syntax: SyntaxNode,
}
impl AstNode for ImportItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StructItem` node.
pub struct StructItemNode {
    syntax: SyntaxNode,
}
impl AstNode for StructItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumBody` node.
pub struct EnumBodyNode {
    syntax: SyntaxNode,
}
impl AstNode for EnumBodyNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_BODY_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumBodyItem` node.
pub struct EnumBodyItemNode {
    syntax: SyntaxNode,
}
impl AstNode for EnumBodyItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_BODY_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumVariant` node.
pub struct EnumVariantNode {
    syntax: SyntaxNode,
}
impl AstNode for EnumVariantNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_VARIANT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumVariantType` node.
pub struct EnumVariantTypeNode {
    syntax: SyntaxNode,
}
impl AstNode for EnumVariantTypeNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_VARIANT_TYPE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `FnSignature` node.
pub struct FnSignatureNode {
    syntax: SyntaxNode,
}
impl AstNode for FnSignatureNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_SIGNATURE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `FnInput` node.
pub struct FnInputNode {
    syntax: SyntaxNode,
}
impl AstNode for FnInputNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_INPUT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportTree` node.
pub struct ImportTreeNode {
    syntax: SyntaxNode,
}
impl AstNode for ImportTreeNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_TREE_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportLeaf` node.
pub struct ImportLeafNode {
    syntax: SyntaxNode,
}
impl AstNode for ImportLeafNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_LEAF_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportSegment` node.
pub struct ImportSegmentNode {
    syntax: SyntaxNode,
}
impl AstNode for ImportSegmentNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_SEGMENT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportBranch` node.
pub struct ImportBranchNode {
    syntax: SyntaxNode,
}
impl AstNode for ImportBranchNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_BRANCH_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StructBody` node.
pub struct StructBodyNode {
    syntax: SyntaxNode,
}
impl AstNode for StructBodyNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_BODY_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StructBodyItem` node.
pub struct StructBodyItemNode {
    syntax: SyntaxNode,
}
impl AstNode for StructBodyItemNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_BODY_ITEM_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StructField` node.
pub struct StructFieldNode {
    syntax: SyntaxNode,
}
impl AstNode for StructFieldNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_FIELD_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `PrefixExpr` node.
pub struct PrefixExprNode {
    syntax: SyntaxNode,
}
impl AstNode for PrefixExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PREFIX_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `BinaryExpr` node.
pub struct BinaryExprNode {
    syntax: SyntaxNode,
}
impl AstNode for BinaryExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BINARY_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `CallExpr` node.
pub struct CallExprNode {
    syntax: SyntaxNode,
}
impl AstNode for CallExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CALL_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `LitExpr` node.
pub struct LitExprNode {
    syntax: SyntaxNode,
}
impl AstNode for LitExprNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LIT_EXPR_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `PrefixOp` node.
pub struct PrefixOpNode {
    syntax: SyntaxNode,
}
impl AstNode for PrefixOpNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PREFIX_OP_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `BinaryOp` node.
pub struct BinaryOpNode {
    syntax: SyntaxNode,
}
impl AstNode for BinaryOpNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BINARY_OP_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `NumLit` node.
pub struct NumLitNode {
    syntax: SyntaxNode,
}
impl AstNode for NumLitNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::NUM_LIT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StrLit` node.
pub struct StrLitNode {
    syntax: SyntaxNode,
}
impl AstNode for StrLitNode {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STR_LIT_NODE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
