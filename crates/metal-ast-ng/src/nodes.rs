//! This file is @generated by the build script, do not edit by hand.
use crate::{AstNode, SyntaxKind, SyntaxNode, SyntaxNodeExt, SyntaxToken};
/// Represents the `Name` node.
pub struct Name {
    syntax: SyntaxNode,
}
impl Name {}
impl AstNode for Name {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::NAME
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Visibility` node.
pub struct Vis {
    syntax: SyntaxNode,
}
impl Vis {}
impl AstNode for Vis {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::VIS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Mutability` node.
pub struct Mutness {
    syntax: SyntaxNode,
}
impl Mutness {}
impl AstNode for Mutness {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::MUTNESS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ExprSpecifier` node.
pub struct ExprSpec {
    syntax: SyntaxNode,
}
impl ExprSpec {}
impl AstNode for ExprSpec {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::EXPR_SPEC
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Expr` node.
pub struct Expr {
    syntax: SyntaxNode,
}
impl Expr {}
impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `TypeQualifier` node.
pub struct TypeQual {
    syntax: SyntaxNode,
}
impl TypeQual {}
impl AstNode for TypeQual {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::TYPE_QUAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Type` node.
pub struct Type {
    syntax: SyntaxNode,
}
impl Type {}
impl AstNode for Type {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Block` node.
pub struct Block {
    syntax: SyntaxNode,
}
impl Block {}
impl AstNode for Block {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BLOCK
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `Item` node.
pub struct Item {
    syntax: SyntaxNode,
}
impl Item {}
impl AstNode for Item {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ITEM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ConstItem` node.
pub struct ConstItem {
    syntax: SyntaxNode,
}
impl ConstItem {}
impl AstNode for ConstItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CONST_ITEM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumItem` node.
pub struct EnumItem {
    syntax: SyntaxNode,
}
impl EnumItem {}
impl AstNode for EnumItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_ITEM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `FnItem` node.
pub struct FnItem {
    syntax: SyntaxNode,
}
impl FnItem {}
impl AstNode for FnItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_ITEM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportItem` node.
pub struct ImportItem {
    syntax: SyntaxNode,
}
impl ImportItem {}
impl AstNode for ImportItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_ITEM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StructItem` node.
pub struct StructItem {
    syntax: SyntaxNode,
}
impl StructItem {}
impl AstNode for StructItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_ITEM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumBody` node.
pub struct EnumBody {
    syntax: SyntaxNode,
}
impl EnumBody {}
impl AstNode for EnumBody {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_BODY
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumBodyItem` node.
pub struct EnumBodyItem {
    syntax: SyntaxNode,
}
impl EnumBodyItem {}
impl AstNode for EnumBodyItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_BODY_ITEM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumVariant` node.
pub struct EnumVariant {
    syntax: SyntaxNode,
}
impl EnumVariant {}
impl AstNode for EnumVariant {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_VARIANT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `EnumVariantType` node.
pub struct EnumVariantType {
    syntax: SyntaxNode,
}
impl EnumVariantType {}
impl AstNode for EnumVariantType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_VARIANT_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `FnSignature` node.
pub struct FnSignature {
    syntax: SyntaxNode,
}
impl FnSignature {}
impl AstNode for FnSignature {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_SIGNATURE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `FnInput` node.
pub struct FnInput {
    syntax: SyntaxNode,
}
impl FnInput {}
impl AstNode for FnInput {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::FN_INPUT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportTree` node.
pub struct ImportTree {
    syntax: SyntaxNode,
}
impl ImportTree {}
impl AstNode for ImportTree {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_TREE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportLeaf` node.
pub struct ImportLeaf {
    syntax: SyntaxNode,
}
impl ImportLeaf {}
impl AstNode for ImportLeaf {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_LEAF
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportSegment` node.
pub struct ImportSegment {
    syntax: SyntaxNode,
}
impl ImportSegment {}
impl AstNode for ImportSegment {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_SEGMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `ImportBranch` node.
pub struct ImportBranch {
    syntax: SyntaxNode,
}
impl ImportBranch {}
impl AstNode for ImportBranch {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_BRANCH
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StructBody` node.
pub struct StructBody {
    syntax: SyntaxNode,
}
impl StructBody {}
impl AstNode for StructBody {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_BODY
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StructBodyItem` node.
pub struct StructBodyItem {
    syntax: SyntaxNode,
}
impl StructBodyItem {}
impl AstNode for StructBodyItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_BODY_ITEM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StructField` node.
pub struct StructField {
    syntax: SyntaxNode,
}
impl StructField {}
impl AstNode for StructField {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_FIELD
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `PrefixExpr` node.
pub struct PrefixExpr {
    syntax: SyntaxNode,
}
impl PrefixExpr {}
impl AstNode for PrefixExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PREFIX_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `BinaryExpr` node.
pub struct BinaryExpr {
    syntax: SyntaxNode,
}
impl BinaryExpr {}
impl AstNode for BinaryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BINARY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `CallExpr` node.
pub struct CallExpr {
    syntax: SyntaxNode,
}
impl CallExpr {}
impl AstNode for CallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CALL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `LitExpr` node.
pub struct LitExpr {
    syntax: SyntaxNode,
}
impl LitExpr {}
impl AstNode for LitExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LIT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `PrefixOp` node.
pub struct PrefixOp {
    syntax: SyntaxNode,
}
impl PrefixOp {}
impl AstNode for PrefixOp {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PREFIX_OP
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `BinaryOp` node.
pub struct BinaryOp {
    syntax: SyntaxNode,
}
impl BinaryOp {}
impl AstNode for BinaryOp {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BINARY_OP
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `NumLit` node.
pub struct NumLit {
    syntax: SyntaxNode,
}
impl NumLit {}
impl AstNode for NumLit {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::NUM_LIT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
/// Represents the `StrLit` node.
pub struct StrLit {
    syntax: SyntaxNode,
}
impl StrLit {}
impl AstNode for StrLit {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STR_LIT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
