//! This file is @generated by the build script, do not edit by hand.
use crate::{AstToken, SyntaxKind, SyntaxToken};
/// Represents the `@ident` token.
pub struct LitIdent {
    syntax: SyntaxToken,
}
impl AstToken for LitIdent {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LIT_IDENT
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `pub` token.
pub struct Pub {
    syntax: SyntaxToken,
}
impl AstToken for Pub {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PUB
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `mut` token.
pub struct Mut {
    syntax: SyntaxToken,
}
impl AstToken for Mut {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::MUT
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `=` token.
pub struct Eq {
    syntax: SyntaxToken,
}
impl AstToken for Eq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `:` token.
pub struct Colon {
    syntax: SyntaxToken,
}
impl AstToken for Colon {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::COLON
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `{` token.
pub struct LBrace {
    syntax: SyntaxToken,
}
impl AstToken for LBrace {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::L_BRACE
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `}` token.
pub struct RBrace {
    syntax: SyntaxToken,
}
impl AstToken for RBrace {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::R_BRACE
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `const` token.
pub struct Const {
    syntax: SyntaxToken,
}
impl AstToken for Const {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CONST
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `enum` token.
pub struct Enum {
    syntax: SyntaxToken,
}
impl AstToken for Enum {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `,` token.
pub struct Comma {
    syntax: SyntaxToken,
}
impl AstToken for Comma {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::COMMA
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `(` token.
pub struct LParen {
    syntax: SyntaxToken,
}
impl AstToken for LParen {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::L_PAREN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `)` token.
pub struct RParen {
    syntax: SyntaxToken,
}
impl AstToken for RParen {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::R_PAREN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `def` token.
pub struct Def {
    syntax: SyntaxToken,
}
impl AstToken for Def {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::DEF
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `import` token.
pub struct Import {
    syntax: SyntaxToken,
}
impl AstToken for Import {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `;` token.
pub struct Semicolon {
    syntax: SyntaxToken,
}
impl AstToken for Semicolon {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::SEMICOLON
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `.` token.
pub struct Dot {
    syntax: SyntaxToken,
}
impl AstToken for Dot {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::DOT
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `struct` token.
pub struct Struct {
    syntax: SyntaxToken,
}
impl AstToken for Struct {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `+` token.
pub struct Plus {
    syntax: SyntaxToken,
}
impl AstToken for Plus {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PLUS
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `-` token.
pub struct Minus {
    syntax: SyntaxToken,
}
impl AstToken for Minus {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::MINUS
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `!` token.
pub struct Bang {
    syntax: SyntaxToken,
}
impl AstToken for Bang {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BANG
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `~` token.
pub struct Tilde {
    syntax: SyntaxToken,
}
impl AstToken for Tilde {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::TILDE
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `+=` token.
pub struct PlusEq {
    syntax: SyntaxToken,
}
impl AstToken for PlusEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PLUS_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `-=` token.
pub struct MinusEq {
    syntax: SyntaxToken,
}
impl AstToken for MinusEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::MINUS_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `/=` token.
pub struct SlashEq {
    syntax: SyntaxToken,
}
impl AstToken for SlashEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::SLASH_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `*=` token.
pub struct StarEq {
    syntax: SyntaxToken,
}
impl AstToken for StarEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STAR_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `**=` token.
pub struct Star2Eq {
    syntax: SyntaxToken,
}
impl AstToken for Star2Eq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STAR2_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `%=` token.
pub struct PercentEq {
    syntax: SyntaxToken,
}
impl AstToken for PercentEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PERCENT_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `^=` token.
pub struct CaretEq {
    syntax: SyntaxToken,
}
impl AstToken for CaretEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CARET_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `&=` token.
pub struct AmpEq {
    syntax: SyntaxToken,
}
impl AstToken for AmpEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::AMP_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `|=` token.
pub struct PipeEq {
    syntax: SyntaxToken,
}
impl AstToken for PipeEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PIPE_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `<<=` token.
pub struct ShiftlEq {
    syntax: SyntaxToken,
}
impl AstToken for ShiftlEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::SHIFTL_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `>>=` token.
pub struct ShiftrEq {
    syntax: SyntaxToken,
}
impl AstToken for ShiftrEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::SHIFTR_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `/` token.
pub struct Slash {
    syntax: SyntaxToken,
}
impl AstToken for Slash {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::SLASH
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `*` token.
pub struct Star {
    syntax: SyntaxToken,
}
impl AstToken for Star {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STAR
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `**` token.
pub struct Star2 {
    syntax: SyntaxToken,
}
impl AstToken for Star2 {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STAR2
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `%` token.
pub struct Percent {
    syntax: SyntaxToken,
}
impl AstToken for Percent {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PERCENT
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `&&` token.
pub struct Amp2 {
    syntax: SyntaxToken,
}
impl AstToken for Amp2 {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::AMP2
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `||` token.
pub struct Pipe2 {
    syntax: SyntaxToken,
}
impl AstToken for Pipe2 {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PIPE2
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `==` token.
pub struct Eq2 {
    syntax: SyntaxToken,
}
impl AstToken for Eq2 {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::EQ2
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `!=` token.
pub struct BangEq {
    syntax: SyntaxToken,
}
impl AstToken for BangEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BANG_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `>` token.
pub struct Gt {
    syntax: SyntaxToken,
}
impl AstToken for Gt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::GT
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `>=` token.
pub struct GtEq {
    syntax: SyntaxToken,
}
impl AstToken for GtEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::GT_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `<` token.
pub struct Lt {
    syntax: SyntaxToken,
}
impl AstToken for Lt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LT
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `<=` token.
pub struct LtEq {
    syntax: SyntaxToken,
}
impl AstToken for LtEq {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LT_EQ
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `^` token.
pub struct Caret {
    syntax: SyntaxToken,
}
impl AstToken for Caret {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CARET
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `&` token.
pub struct Amp {
    syntax: SyntaxToken,
}
impl AstToken for Amp {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::AMP
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `|` token.
pub struct Pipe {
    syntax: SyntaxToken,
}
impl AstToken for Pipe {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PIPE
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `<<` token.
pub struct Lt2 {
    syntax: SyntaxToken,
}
impl AstToken for Lt2 {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LT2
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `>>` token.
pub struct Gt2 {
    syntax: SyntaxToken,
}
impl AstToken for Gt2 {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::GT2
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `..` token.
pub struct Dot2 {
    syntax: SyntaxToken,
}
impl AstToken for Dot2 {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::DOT2
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `@number` token.
pub struct LitNum {
    syntax: SyntaxToken,
}
impl AstToken for LitNum {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LIT_NUM
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
/// Represents the `@string` token.
pub struct LitStr {
    syntax: SyntaxToken,
}
impl AstToken for LitStr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LIT_STR
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
