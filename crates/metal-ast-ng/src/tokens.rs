//! This file is @generated by the build script, do not edit by hand.
use crate::{AstToken, SyntaxKind, SyntaxToken};
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `@ident` token.
pub struct LitIdentToken {
    syntax: SyntaxToken,
}
impl AstToken for LitIdentToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LIT_IDENT_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `pub` token.
pub struct PubToken {
    syntax: SyntaxToken,
}
impl AstToken for PubToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PUB_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `mut` token.
pub struct MutToken {
    syntax: SyntaxToken,
}
impl AstToken for MutToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::MUT_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `=` token.
pub struct EqToken {
    syntax: SyntaxToken,
}
impl AstToken for EqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `:` token.
pub struct ColonToken {
    syntax: SyntaxToken,
}
impl AstToken for ColonToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::COLON_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `{` token.
pub struct LBraceToken {
    syntax: SyntaxToken,
}
impl AstToken for LBraceToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::L_BRACE_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `}` token.
pub struct RBraceToken {
    syntax: SyntaxToken,
}
impl AstToken for RBraceToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::R_BRACE_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `const` token.
pub struct ConstToken {
    syntax: SyntaxToken,
}
impl AstToken for ConstToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CONST_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `enum` token.
pub struct EnumToken {
    syntax: SyntaxToken,
}
impl AstToken for EnumToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::ENUM_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `,` token.
pub struct CommaToken {
    syntax: SyntaxToken,
}
impl AstToken for CommaToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::COMMA_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `(` token.
pub struct LParenToken {
    syntax: SyntaxToken,
}
impl AstToken for LParenToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::L_PAREN_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `)` token.
pub struct RParenToken {
    syntax: SyntaxToken,
}
impl AstToken for RParenToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::R_PAREN_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `def` token.
pub struct DefToken {
    syntax: SyntaxToken,
}
impl AstToken for DefToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::DEF_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `import` token.
pub struct ImportToken {
    syntax: SyntaxToken,
}
impl AstToken for ImportToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::IMPORT_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `;` token.
pub struct SemicolonToken {
    syntax: SyntaxToken,
}
impl AstToken for SemicolonToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::SEMICOLON_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `.` token.
pub struct DotToken {
    syntax: SyntaxToken,
}
impl AstToken for DotToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::DOT_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `struct` token.
pub struct StructToken {
    syntax: SyntaxToken,
}
impl AstToken for StructToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STRUCT_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `+` token.
pub struct PlusToken {
    syntax: SyntaxToken,
}
impl AstToken for PlusToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PLUS_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `-` token.
pub struct MinusToken {
    syntax: SyntaxToken,
}
impl AstToken for MinusToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::MINUS_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `!` token.
pub struct BangToken {
    syntax: SyntaxToken,
}
impl AstToken for BangToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BANG_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `~` token.
pub struct TildeToken {
    syntax: SyntaxToken,
}
impl AstToken for TildeToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::TILDE_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `+=` token.
pub struct PlusEqToken {
    syntax: SyntaxToken,
}
impl AstToken for PlusEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PLUS_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `-=` token.
pub struct MinusEqToken {
    syntax: SyntaxToken,
}
impl AstToken for MinusEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::MINUS_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `/=` token.
pub struct SlashEqToken {
    syntax: SyntaxToken,
}
impl AstToken for SlashEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::SLASH_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `*=` token.
pub struct StarEqToken {
    syntax: SyntaxToken,
}
impl AstToken for StarEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STAR_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `**=` token.
pub struct Star2EqToken {
    syntax: SyntaxToken,
}
impl AstToken for Star2EqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STAR2_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `%=` token.
pub struct PercentEqToken {
    syntax: SyntaxToken,
}
impl AstToken for PercentEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PERCENT_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `^=` token.
pub struct CaretEqToken {
    syntax: SyntaxToken,
}
impl AstToken for CaretEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CARET_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `&=` token.
pub struct AmpEqToken {
    syntax: SyntaxToken,
}
impl AstToken for AmpEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::AMP_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `|=` token.
pub struct PipeEqToken {
    syntax: SyntaxToken,
}
impl AstToken for PipeEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PIPE_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `<<=` token.
pub struct ShiftlEqToken {
    syntax: SyntaxToken,
}
impl AstToken for ShiftlEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::SHIFTL_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `>>=` token.
pub struct ShiftrEqToken {
    syntax: SyntaxToken,
}
impl AstToken for ShiftrEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::SHIFTR_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `/` token.
pub struct SlashToken {
    syntax: SyntaxToken,
}
impl AstToken for SlashToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::SLASH_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `*` token.
pub struct StarToken {
    syntax: SyntaxToken,
}
impl AstToken for StarToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STAR_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `**` token.
pub struct Star2Token {
    syntax: SyntaxToken,
}
impl AstToken for Star2Token {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::STAR2_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `%` token.
pub struct PercentToken {
    syntax: SyntaxToken,
}
impl AstToken for PercentToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PERCENT_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `&&` token.
pub struct Amp2Token {
    syntax: SyntaxToken,
}
impl AstToken for Amp2Token {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::AMP2_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `||` token.
pub struct Pipe2Token {
    syntax: SyntaxToken,
}
impl AstToken for Pipe2Token {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PIPE2_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `==` token.
pub struct Eq2Token {
    syntax: SyntaxToken,
}
impl AstToken for Eq2Token {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::EQ2_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `!=` token.
pub struct BangEqToken {
    syntax: SyntaxToken,
}
impl AstToken for BangEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::BANG_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `>` token.
pub struct GtToken {
    syntax: SyntaxToken,
}
impl AstToken for GtToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::GT_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `>=` token.
pub struct GtEqToken {
    syntax: SyntaxToken,
}
impl AstToken for GtEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::GT_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `<` token.
pub struct LtToken {
    syntax: SyntaxToken,
}
impl AstToken for LtToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LT_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `<=` token.
pub struct LtEqToken {
    syntax: SyntaxToken,
}
impl AstToken for LtEqToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LT_EQ_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `^` token.
pub struct CaretToken {
    syntax: SyntaxToken,
}
impl AstToken for CaretToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::CARET_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `&` token.
pub struct AmpToken {
    syntax: SyntaxToken,
}
impl AstToken for AmpToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::AMP_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `|` token.
pub struct PipeToken {
    syntax: SyntaxToken,
}
impl AstToken for PipeToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::PIPE_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `<<` token.
pub struct Lt2Token {
    syntax: SyntaxToken,
}
impl AstToken for Lt2Token {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LT2_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `>>` token.
pub struct Gt2Token {
    syntax: SyntaxToken,
}
impl AstToken for Gt2Token {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::GT2_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `..` token.
pub struct Dot2Token {
    syntax: SyntaxToken,
}
impl AstToken for Dot2Token {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::DOT2_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `@number` token.
pub struct LitNumToken {
    syntax: SyntaxToken,
}
impl AstToken for LitNumToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LIT_NUM_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
/// Represents the `@string` token.
pub struct LitStrToken {
    syntax: SyntaxToken,
}
impl AstToken for LitStrToken {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SyntaxKind::LIT_STR_TOKEN
    }
    fn cast(syntax: SyntaxToken) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxToken {
        &self.syntax
    }
}
